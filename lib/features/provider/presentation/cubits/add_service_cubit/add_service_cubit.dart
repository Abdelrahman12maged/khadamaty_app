import 'package:firebase_auth/firebase_auth.dart';
import 'package:flutter_bloc/flutter_bloc.dart';
import '../../../domain/entities/service_entity.dart';
import 'dart:io';
import 'package:image_picker/image_picker.dart';
import '../../../domain/usecases/create_service_usecase.dart';
import '../../../domain/usecases/upload_image_usecase.dart';
import 'add_service_state.dart';

/// Cubit for managing Add Service form
class AddServiceCubit extends Cubit<AddServiceState> {
  final CreateServiceUseCase _createServiceUseCase;
  final UploadImageUseCase _uploadImageUseCase;
  final FirebaseAuth _auth;

  AddServiceCubit({
    required CreateServiceUseCase createServiceUseCase,
    required UploadImageUseCase uploadImageUseCase,
    FirebaseAuth? auth,
  })  : _createServiceUseCase = createServiceUseCase,
        _uploadImageUseCase = uploadImageUseCase,
        _auth = auth ?? FirebaseAuth.instance,
        super(const AddServiceState());

  /// Update title
  void updateTitle(String title) {
    emit(state.copyWith(title: title, clearError: true));
  }

  /// Update description
  void updateDescription(String description) {
    emit(state.copyWith(description: description, clearError: true));
  }

  /// Update category
  void updateCategory(String category) {
    emit(state.copyWith(category: category, clearError: true));
  }

  /// Update price
  void updatePrice(double? price) {
    emit(state.copyWith(price: price, clearError: true));
  }

  /// Update price unit
  void updatePriceUnit(String priceUnit) {
    emit(state.copyWith(priceUnit: priceUnit));
  }

  /// Update service type
  void updateServiceType(ServiceType serviceType) {
    emit(state.copyWith(serviceType: serviceType));
  }

  /// Update duration (for appointment services)
  void updateDuration(int? minutes) {
    emit(state.copyWith(durationMinutes: minutes));
  }

  /// Update availability (for appointment services)
  void updateAvailability(ServiceAvailability availability) {
    emit(state.copyWith(availability: availability));
  }

  /// Update location
  void updateLocation({
    required double latitude,
    required double longitude,
    String? address,
  }) {
    emit(state.copyWith(
      latitude: latitude,
      longitude: longitude,
      address: address,
      clearError: true,
    ));
  }

  /// Clear location
  void clearLocation() {
    emit(state.copyWith(clearLocation: true));
  }

  /// Pick and upload image
  Future<void> pickAndUploadImage() async {
    try {
      final picker = ImagePicker();
      final pickedFile = await picker.pickImage(
        source: ImageSource.gallery,
        imageQuality: 70,
      );

      if (pickedFile == null) return;

      final currentUser = _auth.currentUser;
      if (currentUser == null) {
        emit(state.copyWith(
          status: AddServiceStatus.error,
          error: 'User not authenticated',
        ));
        return;
      }

      emit(state.copyWith(status: AddServiceStatus.loading));

      final file = File(pickedFile.path);
      final fileName = 'services/${DateTime.now().millisecondsSinceEpoch}.jpg';

      final result = await _uploadImageUseCase(file, fileName);

      result.fold(
        (failure) => emit(state.copyWith(
          status: AddServiceStatus.error,
          error: failure.message,
        )),
        (url) => emit(state.copyWith(
          status: AddServiceStatus.initial,
          imageUrl: url,
        )),
      );
    } catch (e) {
      emit(state.copyWith(
        status: AddServiceStatus.error,
        error: 'Failed to pick/upload image: ${e.toString()}',
      ));
    }
  }

  /// Submit form to Firebase
  Future<ServiceEntity?> submitForm() async {
    // Mark that submit was attempted (for showing validation errors)
    emit(state.copyWith(hasAttemptedSubmit: true));

    // Validate
    if (!state.isValid) {
      return null;
    }

    // Get current user
    final currentUser = _auth.currentUser;
    if (currentUser == null) {
      emit(state.copyWith(
        status: AddServiceStatus.error,
        error: 'User not authenticated',
      ));
      return null;
    }

    try {
      emit(state.copyWith(status: AddServiceStatus.loading));

      // Create service entity
      final service = ServiceEntity(
        id: '', // Will be generated by Firestore
        providerId: currentUser.uid,
        providerName: currentUser.displayName ?? 'Unknown',
        title: state.title,
        description: state.description,
        category: state.category,
        serviceType: state.serviceType,
        price: state.price!,
        priceUnit: state.priceUnit,
        durationMinutes: state.durationMinutes,
        imageUrl: state.imageUrl,
        location: ServiceLocation(
          latitude: state.latitude!,
          longitude: state.longitude!,
          address: state.address ?? '',
        ),
        availability: state.isAppointmentService ? state.availability : null,
        createdAt: DateTime.now(),
      );

      // Save to Firebase via UseCase
      final result = await _createServiceUseCase(service);

      return result.fold(
        (failure) {
          emit(state.copyWith(
            status: AddServiceStatus.error,
            error: failure.message,
          ));
          return null;
        },
        (createdService) {
          emit(state.copyWith(
            status: AddServiceStatus.success,
            createdService: createdService,
          ));
          return createdService;
        },
      );
    } catch (e) {
      emit(state.copyWith(
        status: AddServiceStatus.error,
        error: 'Failed to create service: ${e.toString()}',
      ));
      return null;
    }
  }

  /// Reset form
  void reset() {
    emit(const AddServiceState());
  }
}
